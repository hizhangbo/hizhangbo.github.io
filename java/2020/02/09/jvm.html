<!DOCTYPE HTML><title>Bob’s Blog</title><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /> <!--[if lte IE 8]><script src="https://cdn.bootcss.com/html5shiv/3.6.2/html5shiv.js"></script><![endif]--><link rel="stylesheet" href="/assets/css/main.css" /> <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]--> <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]--> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?62888767648ab0a78f7107ed1f6dc242"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script src='//unpkg.com/valine/dist/Valine.min.js'></script><body oncontextmenu="return false;" onselectstart="return false"><div id="wrapper"><header id="header"><h1><a href="/index.html">記憶 備份</a></h1><nav class="links"><ul><li><a href="/#about">關於我</a></ul></nav><nav class="main"><ul><li class="light"> <input type="checkbox" class="checke"><li class="menu"> <a class="fa-bars" href="#menu">Menu</a></ul></nav></header><section id="menu"><section> <form class="search" method="get" action="#"> <input type="text" name="query" placeholder="Search" id="search-input" /> </form></section><section><div id="results-container"></div></section></section><div id="main"><article class="post"><h1 id="jvm-結構解析">JVM 結構解析</h1><hr /><p><img src="/images/content/JVM.png" class="image featured" alt="JVM" align="center" /></p><h3 id="基本結構">基本結構</h3><ul><li><strong>类加载器</strong><ul><li>抽象类<ul><li>loadClass<li>defineClass<li>findClass<li>findLoadedClass</ul><li>分类<ul><li>BootStrap ClassLoader -&gt; rt.jar /-Xbootclasspath<ul><li>-Xbootclasspath/a:/var/lib</ul><li>Extension ClassLoader -&gt; %JAVA_HOME%/lib/ext/*.jar<li>App ClassLoader -&gt; classpath<li>Custom ClassLoader</ul><li>过程<ul><li>加载(双亲模式)<ul><li>自底向上检查类是否已经加载<li>自顶向下尝试加载类<li>类的二进制流，转为方法区数据结构，生成对应的java.lang.Class对象</ul><li>链接<ul><li>验证<ul><li>文件格式<li>元数据<li>字节码</ul><li>准备<ul><li>分配内存，并为类设置初始化方法区</ul><li>解析<ul><li>符号引用替换直接引用</ul></ul><li>初始化<ul><li>执行类构造器 <strong>&lt;clinit&gt;</strong><ul><li>static变量 赋值语句<li>static{}静态代码块</ul><li>子类的<strong>&lt;clinit&gt;</strong>调用前一定保证父类的<strong>&lt;clinit&gt;</strong>已被调用</ul></ul></ul></ul><hr /><ul><li><strong>内存空间</strong><ul><li>方法区<ul><li>保存装载的类信息<ul><li>类型的常量池<li>字段，方法信息<li>方法字节码</ul><li>通常和永久区Perm关联在一起（java8以后PermGen被Metaspace替代）<ul><li>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存</ul></ul><li>堆<ul><li>对象存储<li>所有线程共享<li>对分代GC来说，堆也是分代的<ul><li>eden<li>s0<li>s1<li>tenured</ul><li>GC的主要工作区间</ul><li>栈<ul><li>线程私有<li>栈由一系列帧组成<li>帧保存一个方法的局部变量表、操作数栈、常量池指针<li>每一次方法调用创建一个帧，并压栈<li>栈上分配<ul><li>小对象（几十bytes），在没有逃逸的情况下<li>大对象或者逃逸对象无法栈上分配<ul><li>逃逸指非线程私有</ul><li>启动参数增加-XX:+DoEscapeAnalysis，减少GC(-XX:PrintGC)</ul><li>本地方法栈(native)</ul></ul></ul><hr /><ul><li>PC寄存器<ul><li>每一个线程拥有一个PC寄存器<li>在线程创建时创建<li>指向下一条指令的地址（當前指令的調用者）<li>执行本地方法时，PC的值为undefined</ul><li><strong>执行引擎</strong><ul><li>解析执行器（对字节码指令逐行解释执行）<li>JIT编译器（编译热点代码为机器指令，缓存在本地方法区）<li><strong>垃圾收集器</strong></ul><li>本地方法接口<li>本地方法库</ul><hr /><h3 id="垃圾回收">垃圾回收</h3><ul><li>算法<ul><li>引用计数法<ul><li>循环引用导致内存泄露</ul><li>标记清除<ul><li>从根节点标记可达引用对象，其余不可达的对象全部清除</ul><li>标记压缩<ul><li>在标记清除基础上，压缩可达对象空间</ul><li>复制算法<ul><li>两块大小相同的内存，第一块内存空间中所有存活对象被复制到另外一块中，然后对第一块进行清理<li>每次复制清除后，第一块和第二块内存空间角色对调<li>空间较为浪费，只存放小对象</ul><li>分代思想<ul><li>新生代<ul><li>少量较小对象存活，适合复制算法</ul><li>老年代<ul><li>大量对象存活，或较大对象，适合标记清除/标记压缩算法</ul></ul></ul><li>可触及性<ul><li>可触及<li>不可触及<li>可复活<ul><li>重写对象的finalize方法，只会被调用一次，避免使用</ul><li>根节点<ul><li>栈中引用的对象<li>方法去中静态成员/常量引用对象<li>JNI方法栈中引用对象</ul></ul><li>Stop-The-World<ul><li>JVM中全局暂停<ul><li>Dump线程<li>死锁检查<li>堆Dump</ul></ul><li>GC 参数<ul><li>-XX:MaxGCPauseMills<ul><li>GC最大停顿时间</ul><li>-XX:GCTimeRatio<ul><li>单位时间内应用的GC使用CPU占比</ul><li>串行回收器<ul><li>-XX:+UseSerialGC<li>单线程回收<li>新生代复制算法<li>老年代标记压缩算法</ul><li>并行回收器<ul><li>ParNew<ul><li>-XX:+UseParNewGC<ul><li>新生代并行<li>老年代串行</ul><li>-XX:ParallelGCThreads 限制线程数量</ul><li>Parallel<ul><li>-XX:+UseParallelGC<li>-XX:+UseParallelOldGC<li>增加吞吐量</ul></ul><li>CMS回收器（老年代）<ul><li>-XX:+UseConcMarkSweepGC<ul><li>并发标记清除<li>和应用程序一起进行<li>减少停顿时间<li>减少吞吐量</ul><li>-XX:+UseCMSCompactAtFullCollection<li>-XX:+CMSFullGCsBeforeCompaction<li>-XX:ParallelCMSThreads<li>过程<ul><li>初始标记<ul><li>根可达对象，速度快，单独进行</ul><li>并发标记<ul><li>主要标记过程，和应用程序进程一起进行</ul><li>重新标记<ul><li>在并发标记时，应用产生的垃圾进行标记，单独进行</ul><li>并发清理<ul><li>清理垃圾对象，和应用程序进程一起进行</ul></ul><li>碎片<ul><li>标记清除产生内存碎片<li></ul></ul></ul><li>GC Roots 判断引用可达<ul><li>栈中引用的对象（局部变量表）<li>方法区中的类静态属性引用的对象<li>方法区中常量引用的对象<li>本地方法栈中JNI（Native方法）引用的对象</ul><li>引用分类及GC<ul><li>强引用 Reference<ul><li>默认</ul><li>软引用 SoftReference<ul><li>内存够用就保留，内存不够用就回收</ul><li>弱引用 WeakReference<ul><li>只要GC进行就会被回收<li>WeakHashMap<ul><li>缓存</ul></ul><li>虚引用 PhantomReference<ul><li>在任何时候都可能被垃圾回收器回收<li>ReferenceQueue 在GC时放到引用队列<li>finalize()方法</ul></ul></ul><hr /><h3 id="内存拷貝">内存拷貝</h3><ul><li>每一个线程有一个工作内存和独立主存<li>工作内存存放主存中变量的值的拷贝<li>volatile 关键字可以使JMM将工作内存中的改变及时同步到主存中<ul><li>可见性<ul><li>其他可见性关键字<ul><li>synchronized<li>final</ul></ul><li>有序性<ul><li>一个线程内的操作都是有序的<li>在该线程外观察操作是无序的（指令重排/主内存同步延时）</ul><li>指令重排<ul><li>没有语义冲突有可能被重排<li>编译器不考虑多线程间的语义，如果要保证顺序使用synchronized</ul></ul></ul><hr /><h3 id="參數調優">參數調優</h3><ul><li>Trace跟踪参数<ul><li>-Xloggc:log/gc.log<li>-XX:+PrintHeapAtGC<li>-XX:+TraceClassLoading<li>-XX:+PrintClassHistogram (ctrl+break 触发打印类的使用情况)<li>-verbose:gc<li>-XX:+printGC<li>-XX:+printGCDetails<li>-XX:+printGCTimeStamps # 打印GC发生的时间戳<ul><li>new generation<ul><li>eden space<li>from space<li>to space</ul><li>tenured generation<li>compacting perm gen<li>ro space<li>rw space</ul></ul><li>堆的分配参数<ul><li>参数类型<ul><li>标配参数<ul><li>java -version</ul><li>X 参数<ul><li>-Xint 解释执行<li>-Xcomp 第一次使用就编译成本地代码<li>-Xmixed 混合模式，编译执行</ul><li>XX 参数</ul><li>总体配置<ul><li>Xms<li>Xmx<ul><li>设置相同，防止抖动</ul></ul><li>新生代<ul><li>-Xmn (新生代)<li>-XX:NewRatio （新生代和老年代的比值）<li>幸存代<ul><li>XX:SurvivorRatio （Survivor和eden的比值）</ul></ul><li>OOM时触发<ul><li>-XX:+HeapDumpOnOutOfMemoryError<li>-XX:+HeapDumpPath</ul></ul><li><del>PermGen参数</del>（java8 中已废弃）<ul><li>-XX:PermSize<li>-XX:MaxPermSize</ul><li>栈的分配参数<ul><li>Xss<ul><li>通常几百K<li>决定函数调用深度</ul></ul><li>JIT及其相关参数<ul><li>-XX:CompileThreshold=1000<li>-XX:+PrintCompilation<li>Xint # 解释执行<li>Xcomp # 编译执行<li>Xmixed # 混合，默认</ul><li>常量池<ul><li>class文件常量池<ul><li>class文件常量池位于class文件中</ul><li>运行时常量池<ul><li>当类或接口创建时，它的class中的常量池会被用来构造运行时常量池，常量池中的符号引用会被解析成具体的内存地址。运行时常量池是jvm方法区的一部分，它可以在运行时将符号引用解析为直接引用。<li>运行时常量池位于jvm的元空间中(java8)</ul><li>字符串常量池<ul><li>字符串常量池底层实现是一个哈希表，可以通过-XX:StringTableSize参数调整大小。字符串常量池中存储的是字符串对象的引用，而字符串本身是在堆上分配的(java中的对象基本都在堆上分配)。运行时常量池初始化的时候，字面量的符号引用的初始化会用到字符串常量池。String中的intern方法可以在运行时将字符串实例加入字符串常量池。<li>在java1.7以前，字符串常量池是在堆的永久代里面，大小固定，而从java1.7以后，字符串常量池则移动到java堆中了。</ul></ul></ul><hr /><h3 id="鎖">鎖</h3><ul><li>对象头Mark，32位<ul><li>描述对象的hash，索信息，垃圾回收标记，年龄</ul><li>偏向锁/可重入锁<ul><li>-XX:+UseBiasedLocking<li>已获得锁的线程，只要没有竞争，在将来进入同步块时不需要做同步</ul><li>轻量级锁<ul><li>存放在线程栈中<li>如果有竞争，就会升级为重量级锁</ul><li>自旋锁<ul><li>存在竞争时，线程做几个空操作，不使用系统挂起</ul><li>Jvm获取锁的优先级<ul><li>先获取偏向锁 -&gt; 轻量级锁 -&gt; 自旋锁</ul><li>锁的优化<ul><li>减少锁的持有时间<li>减小锁粒度<ul><li>ConcurrentHashMap<ul><li>由若干个Segment组成<li>每个Segment中维护HashEntry<li>在并发操作时，锁定一个Segment</ul></ul><li>锁粗化<ul><li>锁的请求非常频繁时，可以将操作合并在同一个锁中</ul><li>锁消除<ul><li>-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</ul><li>锁分离<ul><li><table><thead><tr><th>类型<th>读锁<th>写锁<tbody><tr><td>读锁<td>可访问<td>不可访问<tr><td>写锁<td>不可访问<td>不可访问</table></ul><li>CAS<ul><li>乐观锁<li>Compare And Swap<li>CAS(V,E,N) V要更新的变量，E期望当前值，N新值<li>AtomicInteger 中getAndSet使用CAS</ul></ul></ul><hr /><h3 id="性能監控">性能監控</h3><ul><li>系统性能监控<ul><li>uptime<li>vmstat<li>pidstat</ul><li>jdk自带工具<ul><li>命令行<ul><li>jps -lv<li>jinfo -flag # 查看jvm启动参数<ul><li>jinfo -flags pid</ul><li>jmap -histo pid # 类对象使用情况<li>jstack pid<li>jstatus</ul><li>图形化<ul><li>JConsole<li>Visual VM</ul></ul><li>OOM<ul><li>MAT<ul><li>浅堆<ul><li>一个对象结构所占用的内存大小，元数据大小</ul><li>深堆<ul><li>一个对象被GC后，可是真是释放的内存大小，对象大小</ul></ul></ul></ul><hr /><h3 id="字節碼文件">字節碼文件</h3><ul><li>Class文件结构<ul><li>magic<li>小版本号<li>大版本号<li>常量池<li>访问标识符<li>接口<li>字段<li>方法<li>attribute</ul><li>字节码对照<ul><li>ASM 实现AOP<ul><li>ClassVisitor</ul></ul></ul><hr /><h3 id="常見錯誤">常見錯誤</h3><ul><li>Throwable<ul><li>Exception<ul><li>RuntimeException</ul><li>Error<ul><li>StackOverflowError # 递归深度调用<li>OutOfMemoryError<ul><li>Java heap space # 对象过多<li>GC overhead limit exceeded # GC占用80%资源回收，但效果不明显，则抛出<li>Direct buffer memory # NIO<li>unable to create new native thread # 线程创建太多<li>Metaspace #</ul></ul></ul></ul></article><div id="vcomments"></div><ul class="actions pagination"><li><a title="Jekyll 遷移" href="/jekyll/ruby/2020/02/08/jekyll.html" class="button big previous">Previous</a><li><a title="Shell 語法" href="/linux/2020/02/09/shell.html" class="button big next">Next</a><li id="/java/2020/02/09/jvm.html" class="leancloud_visitors" style="float: right;"><a class="icon fa-eye leancloud-visitors-count" aria-hidden="true"></a></ul></div><script> new Valine({ el: '#vcomments' , appId: 'VDYHbJKU0wCisABJmYCE1jaY-gzGzoHsz', appKey: '1CSpcPFQ88n8LBW7SjpAbMIc', notify:false, verify:false, avatar:'mp', placeholder: '若有疏失，還望指正', visitor: true, recordIP: true }); </script></div><div id="leftsead"><ul><li class="top"> ↑<li class="bottom"> ↑</ul></div><script src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="https://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script> <script src="https://cdn.bootcss.com/skel/3.0.0/skel.min.js"></script> <!--[if lte IE 8]><script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script><![endif]--> <script src="/assets/js/main.js"></script> <script src="/assets/js/util.js"></script> <script src="/assets/js/search.js"></script> <script> new Valine({ el: '#vcomments', appId: 'VDYHbJKU0wCisABJmYCE1jaY-gzGzoHsz', appKey: '1CSpcPFQ88n8LBW7SjpAbMIc' }) </script>
