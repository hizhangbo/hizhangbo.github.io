<!DOCTYPE HTML><title>Bob’s Blog</title><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /> <!--[if lte IE 8]><script src="https://cdn.bootcss.com/html5shiv/3.6.2/html5shiv.js"></script><![endif]--><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hizhangbo/hizhangbo.github.io@v0.1/assets/css/main.css" /> <!--[if lte IE 9]><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hizhangbo/hizhangbo.github.io@v0.1/assets/css/ie9.css" /><![endif]--> <!--[if lte IE 8]><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hizhangbo/hizhangbo.github.io@v0.1/assets/css/ie8.css" /><![endif]--> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?62888767648ab0a78f7107ed1f6dc242"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script src='//unpkg.com/valine/dist/Valine.min.js'></script><body oncontextmenu="return false;" onselectstart="return false"><div id="wrapper"><header id="header"><h1><a href="/index.html">記憶 備份</a></h1><nav class="links"><ul><li><a href="/#about">關於我</a></ul></nav><nav class="main"><ul><li class="light"> <input type="checkbox" class="checke"><li class="menu"> <a class="fa-bars" href="#menu">Menu</a></ul></nav></header><section id="menu"><section> <form class="search" method="get" action="#"> <input type="text" name="query" placeholder="Search" id="search-input" /> </form></section><section><div id="results-container"></div></section></section><div id="main"><article class="post"><h1 id="java相關總結">Java相關總結</h1><h2 id="collection">Collection</h2><hr /><ul><li>HashMap<ul><li>结构：（Java8之后）数组、链表和红黑树<li>树化：TREEIFY_THRESHOLD = 8，链表长度超过8，则转化为红黑树<li>初始容量：16，懒加载<li>加载因子：0.75f<li>加载容量：2*n<li>（Java8之前）并发put导致扩容时出现循环链表，（Java8之后）改用尾插法解决</ul><li>ConcurrentHashMap<ul><li>高并发<ul><li>链表头采用CAS<li><h2 id="如果发生碰撞则升级为synchronized">如果发生碰撞则升级为synchronized</h2></ul></ul><li>ArrayList<ul><li>结构：数组<li>初始容量：10<li>加载因子：1（元素满时）<li>加载容量：1.5*n (向下取整)</ul><li>CopyOnWriteArrayList<ul><li>并发安全<ul><li>ReentrantLock<li>读写分离，写时复制，完成后指向新复制的对象</ul></ul><li>LinkedList<ul><li><h2 id="结构链表">结构：链表</h2></ul><li>HashSet<ul><li>结构：HashMap，value值指定一个默认的Object对象PRESENT</ul><li>CopyOnWriteArraySet<ul><li><h2 id="底层实现为copyonwritearraylist">底层实现为CopyOnWriteArrayList</h2><h2 id="concurrency">Concurrency</h2><hr /></ul><li>synchronized<ul><li>jvm 层面<li>操作<ul><li>wait()<li>notify()<li>notifyAll()</ul><li>底层实现<ul><li>monitorenter<li>monitorexit</ul></ul><li>Lock/ReentrantLock<ul><li>jdk 层面<li>操作<ul><li>await<li>signal<li>signalAll</ul><li>优势<ul><li>公平/非公平自定义<li>锁定时间自定义<li>唤醒多Condition自定义</ul></ul><li>volatile<ul><li>可见性<li>不保证原子性<li>禁止指令重排</ul><li>atomic<ul><li>原子引用</ul><li>锁的升级<ul><li>无锁<li>偏向锁<li>CAS乐观锁<li>自旋锁<li>synchronized</ul><li>CAS<ul><li>比较并交换<li>ABA问题<ul><li><h2 id="增加时间戳版本号解决">增加时间戳/版本号解决</h2><h2 id="锁的分类">锁的分类</h2><hr /></ul></ul><li>公平锁<ul><li>按锁的申请顺序（ordering policy），排队获取锁资源</ul><li>非公平锁<ul><li><h2 id="锁竞争吞吐量高">锁竞争，吞吐量高</h2></ul><li>可重入锁（递归锁）<ul><li>获得锁的线程，无需再次获取相同锁<li><h2 id="避免死锁">避免死锁</h2></ul><li>自旋锁<ul><li><h2 id="循环尝试获取锁可通过-atomicreferencethread实现">循环尝试获取锁，可通过 <code class="highlighter-rouge">AtomicReference&lt;Thread&gt;</code>实现</h2></ul><li>独占锁（写锁）<ul><li>ReentrantReadWriteLock<ul><li>writeLock().lock()</ul></ul><li>共享锁（读锁）<ul><li>ReentrantReadWriteLock<ul><li>readLock().lock()</ul></ul><li><h2 id="互斥锁">互斥锁</h2><h2 id="线程同步">线程同步</h2><hr /><li>CountDownLatch<ul><li>countDown()<li>await()</ul><li>CyclicBarrier<ul><li>await()</ul><li>Semaphore<ul><li>acquire()<li><h2 id="release">release()</h2><h2 id="阻塞队列">阻塞队列</h2></ul><li>生产者与消费者功能分离<li>BlockingQueue<ul><li>ArrayBlockingQueue：数组结构组成的有界阻塞队列<li>LinkedBlockingQueue：链表结构组成的有界阻塞队列，默认大小Integer.MAX_VALUE<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列<li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列<li>LinkedTransferQueue：链表结构组成的无界阻塞队列<li>LinkedBlockingDeque：链表结构组成的双向阻塞队列</ul><li>相关操作<ul><li>抛异常<ul><li>add()<li>remove()<li>element()</ul><li>返回boolean，可加入阻塞等待时间<ul><li>offer()<li>poll()<li>peek()</ul><li>阻塞<ul><li>put()<li><h2 id="take">take()</h2><h2 id="线程池">线程池</h2></ul></ul><li>常见<ul><li>FixedThreadPool<li>SingleThreadExecutor<li>CachedThreadPool</ul><li>自定义参数<ul><li><code class="highlighter-rouge">int corePoolSize</code>：线程池中常驻核心线程数<li><code class="highlighter-rouge">int maximumPoolSize</code>：线程池中同时执行最大线程数，阻塞队列满时线程池扩容<li><code class="highlighter-rouge">long keepAliveTime</code>：超过<code class="highlighter-rouge">corePoolSize</code>的其它线程，空余时存活时间<li><code class="highlighter-rouge">TimeUnit unit</code>：keepAliveTime的单位<li><code class="highlighter-rouge">BlockingQueue&lt;Runnable&gt; workQueue</code>：任务队列，被提交但未被执行，默认<code class="highlighter-rouge">LinkedBlockingQueue</code>，<code class="highlighter-rouge">corePoolSize</code>满时存放<li><code class="highlighter-rouge">ThreadFactory threadFactory</code>：线程池的线程创建工厂<li><h2 id="rejectedexecutionhandler-handler拒绝策略任务队列满时并且工作线程大于等于maximumpoolsize"><code class="highlighter-rouge">RejectedExecutionHandler handler</code>：拒绝策略，任务队列满时，并且工作线程大于等于maximumPoolSize</h2><h2 id="spring">Spring</h2><hr /></ul><li>事务隔离级别 Isolation<ul><li>read uncommitted<li>read committed(锁定正在读取的行)<li>repeatable read(锁定所有行)<li>serializable(锁表)</ul><li>事务传播模式 Propagation<ul><li>required:如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务<li>requires new:总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起<li>supports:如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行<li>not supported:总是非事务地执行，并挂起任何存在的事务<li>mandatory:如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常<li>never:总是非事务地执行，如果存在一个活动事务，则抛出异常<li><h2 id="nested如果一个活动的事务存在则运行在一个嵌套的事务中-如果没有活动事务-则按required">nested:如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按required</h2></ul><li>依赖注入<ul><li>Bean的生命周期<ul><li>BeanDefinition<li>BeanFactory<li>BeanPostProcessor<li>SingletonObjects</ul></ul><li>依赖查询</ul><hr /><ul><li>AOP<ul><li>Java Proxy<ul><li>实现接口</ul><li>cglib<ul><li>ASM字节码</ul></ul></ul><hr /></article><div id="vcomments"></div><ul class="actions pagination"><li><a title="Metricbeat" href="/elasticsearch/2020/02/10/metricbeat.html" class="button big previous">Previous</a><li><a title="Mysql" href="/mysql/2020/02/11/mysql.html" class="button big next">Next</a><li id="/java/2020/02/10/interview.html" class="leancloud_visitors" style="float: right;"><a class="icon fa-eye leancloud-visitors-count" aria-hidden="true"></a></ul></div><script> new Valine({ el: '#vcomments' , appId: 'VDYHbJKU0wCisABJmYCE1jaY-gzGzoHsz', appKey: '1CSpcPFQ88n8LBW7SjpAbMIc', notify:false, verify:false, avatar:'mp', placeholder: '若有疏失，還望指正', visitor: true, recordIP: true }); </script></div><div id="leftsead"><ul><li class="top"> ↑<li class="bottom"> ↑</ul></div><script src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="https://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js"></script> <script src="https://cdn.bootcss.com/skel/3.0.0/skel.min.js"></script> <!--[if lte IE 8]><script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script><![endif]--> <script src="https://cdn.jsdelivr.net/gh/hizhangbo/hizhangbo.github.io@v0.1/assets/js/main.js"></script> <script src="https://cdn.jsdelivr.net/gh/hizhangbo/hizhangbo.github.io@v0.1/assets/js/util.js"></script> <script src="https://cdn.jsdelivr.net/gh/hizhangbo/hizhangbo.github.io@v0.1/assets/js/search.js"></script> <script> new Valine({ el: '#vcomments', appId: 'VDYHbJKU0wCisABJmYCE1jaY-gzGzoHsz', appKey: '1CSpcPFQ88n8LBW7SjpAbMIc' }) </script>
