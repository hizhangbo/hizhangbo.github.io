<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-04-07T00:37:39+08:00</updated><id>/feed.xml</id><title type="html">Bob’s Blog</title><subtitle>Bob’s Blog.Welcome!(●'◡'●)</subtitle><entry><title type="html">InfluxDB 时序数据库</title><link href="/2020/03/27/influxdb.html" rel="alternate" type="text/html" title="InfluxDB 时序数据库" /><published>2020-03-27T21:23:36+08:00</published><updated>2020-03-27T21:23:36+08:00</updated><id>/2020/03/27/influxdb</id><content type="html" xml:base="/2020/03/27/influxdb.html">&lt;h1 id=&quot;influxdb&quot;&gt;InfluxDB&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;docker&quot;&gt;docker&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pull
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull influxdb
docker pull grafana/grafana
docker pull chronograf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;run
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -p 8083:8083 -p8086:8086 --expose 8090 --expose 8099 --name influxdb influxdb
docker run -d -p 3000:3000 --name grafana grafana/grafana
docker run -d -p 8888:8888 -v chronograf:/var/lib/chronograf --name=chronograf chronograf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;influxdb-基本操作&quot;&gt;influxDB 基本操作&lt;/h3&gt;
    &lt;p&gt;```sql
#创建数据库
create database “db_name”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#显示所有的数据库
show databases&lt;/p&gt;

&lt;p&gt;#删除数据库
drop database “db_name”&lt;/p&gt;

&lt;p&gt;#使用数据库
use db_name&lt;/p&gt;

&lt;p&gt;#显示该数据库中所有的表
show measurements&lt;/p&gt;

&lt;p&gt;#删除表
drop measurement “measurement_name”&lt;/p&gt;

&lt;p&gt;#创建表，直接在插入数据的时候指定表名
insert test,host=127.0.0.1,monitor_name=test count=1&lt;/p&gt;

&lt;p&gt;#删除记录 未成功删除？
delete from test where time=1585329531596000000&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### 用户管理
```sql
#可以通过Chronograf页面做操作，也可以命令行。
#显示用户  
show users

#创建用户
create user &quot;username&quot; with password 'password'

#创建管理员权限用户
create user &quot;username&quot; with password 'password' with all privileges

#删除用户
drop user &quot;username&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;建表&quot;&gt;建表&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果某些字段经常作为查询的条件，建议设置为Tag&lt;/li&gt;
  &lt;li&gt;如果查询有Group By 建议设置为Tag&lt;/li&gt;
  &lt;li&gt;如果数据要与InfluxDB的函数一起使用，建议设置为Field&lt;/li&gt;
  &lt;li&gt;如果需要存储为非字符串类型，建议设置为Field&lt;/li&gt;
  &lt;li&gt;如果数据具有动态值，建议设置为Field
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;尽量避免太多的序列，Tag包含大字符串，例如UUID，这会导致数据库负载和内存使用的升高。影响性能的关键角色之一是高系列基数，根据最新的influxdb硬件指南，对于少于100K的唯一系列，它推荐大约2-4 GB的RAM。当一个measurement 有一些高度动态值的Tag,很容易消耗32G内存。它将导致高系列基数。另一方面，当Tag Key 和 值只需要存储一次，它只需要更多的存储空间，不会影响内存的占用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;hr /&gt;
    &lt;h3 id=&quot;过期策略&quot;&gt;过期策略&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;显示过期策略
```sql
    &lt;h1 id=&quot;duration代表多少时间后过期&quot;&gt;duration代表多少时间后过期&lt;/h1&gt;
    &lt;h1 id=&quot;shardgroupduration-代表的是多长时间的数据放在同一个数据文件中&quot;&gt;shardGroupDuration 代表的是多长时间的数据放在同一个数据文件中&lt;/h1&gt;
    &lt;p&gt;SHOW RETENTION POLICIES ON db&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;所有shared数据文件和过期时间&quot;&gt;所有shared数据文件和过期时间&lt;/h1&gt;
&lt;p&gt;SHOW shards&lt;/p&gt;

&lt;h1 id=&quot;修改过期策略&quot;&gt;修改过期策略&lt;/h1&gt;
&lt;p&gt;ALTER RETENTION POLICY “autogen” ON db DURATION 15d REPLICATION 1 SHARD DURATION 1d DEFAULT&lt;/p&gt;

&lt;h1 id=&quot;创建过期策略&quot;&gt;创建过期策略&lt;/h1&gt;
&lt;p&gt;CREATE RETENTION POLICY “one_day_only” ON “NOAA_water_database” DURATION 23h60m REPLICATION 1 DEFAULT
```&lt;/p&gt;</content><author><name>Bob</name></author><summary type="html">InfluxDB docker pull docker pull influxdb docker pull grafana/grafana docker pull chronograf run docker run -d -p 8083:8083 -p8086:8086 --expose 8090 --expose 8099 --name influxdb influxdb docker run -d -p 3000:3000 --name grafana grafana/grafana docker run -d -p 8888:8888 -v chronograf:/var/lib/chronograf --name=chronograf chronograf influxDB 基本操作 ```sql #创建数据库 create database “db_name”</summary></entry><entry><title type="html">Douyu 弹幕解析</title><link href="/2020/03/26/douyu.html" rel="alternate" type="text/html" title="Douyu 弹幕解析" /><published>2020-03-26T12:09:36+08:00</published><updated>2020-03-26T12:09:36+08:00</updated><id>/2020/03/26/douyu</id><content type="html" xml:base="/2020/03/26/douyu.html">&lt;h1 id=&quot;type&quot;&gt;type&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;loginres&lt;/li&gt;
  &lt;li&gt;uenter&lt;/li&gt;
  &lt;li&gt;noble_num_info&lt;/li&gt;
  &lt;li&gt;chatmsg&lt;/li&gt;
  &lt;li&gt;hrkd&lt;/li&gt;
  &lt;li&gt;upgrade&lt;/li&gt;
  &lt;li&gt;mrkl&lt;/li&gt;
  &lt;li&gt;synexp&lt;/li&gt;
  &lt;li&gt;tsboxb&lt;/li&gt;
  &lt;li&gt;frank
```&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;心跳检测周期
2020-03-26T12:26:35.622
2020-03-26T12:27:32.600&lt;/p&gt;

&lt;p&gt;2020-03-26 16:21:24.597
2020-03-26 16:21:53.585&lt;/p&gt;

&lt;p&gt;2020-03-27 00:25:45.220
2020-03-27 00:26:45.273&lt;/p&gt;

&lt;p&gt;type@=chatmsg/rid@=71415/uid@=26955927/nn@=LarryPage/txt@=1/cid@=b47b088092f94b908f874e1100000000/ic@=avanew@Sface@S201610@S29@S23@S1ab4a89dbd8eacb069b9f98a6df6a89b/level@=32/sahf@=0/col@=4/cst@=1585194423077/bnn@=/bl@=0/brid@=0/hc@=/hl@=1/ifs@=1/el@=/lk@=/fl@=17/urlev@=17/dms@=4/
```&lt;/p&gt;</content><author><name>Bob</name></author><summary type="html">type loginres uenter noble_num_info chatmsg hrkd upgrade mrkl synexp tsboxb frank ```</summary></entry><entry><title type="html">Redis</title><link href="/2020/02/13/redis.html" rel="alternate" type="text/html" title="Redis" /><published>2020-02-13T13:57:36+08:00</published><updated>2020-02-13T13:57:36+08:00</updated><id>/2020/02/13/redis</id><content type="html" xml:base="/2020/02/13/redis.html"></content><author><name>Bob</name></author><summary type="html"></summary></entry><entry><title type="html">Kafka</title><link href="/2020/02/12/kafka.html" rel="alternate" type="text/html" title="Kafka" /><published>2020-02-12T13:57:36+08:00</published><updated>2020-02-12T13:57:36+08:00</updated><id>/2020/02/12/kafka</id><content type="html" xml:base="/2020/02/12/kafka.html">&lt;h1 id=&quot;kafka&quot;&gt;Kafka&lt;/h1&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;磁盘存储结构&quot;&gt;磁盘存储结构&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;topic
    &lt;ul&gt;
      &lt;li&gt;partition
        &lt;ul&gt;
          &lt;li&gt;segment
            &lt;ul&gt;
              &lt;li&gt;.index&lt;/li&gt;
              &lt;li&gt;.log&lt;/li&gt;
              &lt;li&gt;.timeindex&lt;/li&gt;
              &lt;li&gt;leader-epoch-checkpoint
***
                &lt;h3 id=&quot;消息同步机制&quot;&gt;消息同步机制&lt;/h3&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;副本半数以上&lt;/li&gt;
  &lt;li&gt;全部同步完成
    &lt;ul&gt;
      &lt;li&gt;ISR
        &lt;ul&gt;
          &lt;li&gt;给定范围内重新选主机制
            &lt;ul&gt;
              &lt;li&gt;同步条数判断优先级，条数越多，优先级越大（已过时，频繁操作zk）&lt;/li&gt;
              &lt;li&gt;时间延迟判断优先级，延迟越低，优先级越大&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据安全性（丢失）
    &lt;ul&gt;
      &lt;li&gt;0：不等待ack&lt;/li&gt;
      &lt;li&gt;1：等待leader节点同步完成即可&lt;/li&gt;
      &lt;li&gt;-1：等待全部ISR中节点同步完成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据一致性
    &lt;ul&gt;
      &lt;li&gt;HW(High Watermark)
        &lt;ul&gt;
          &lt;li&gt;副本中同步最少的偏移量（Consumer可见的最大偏移量）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LEO(Log End Offset)
        &lt;ul&gt;
          &lt;li&gt;副本同步的最新的偏移量&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;幂等性（去重复）
    &lt;ul&gt;
      &lt;li&gt;enable.idompotence=true&lt;/li&gt;
      &lt;li&gt;只保证相同会话的一次写入，如果producer重新连接，PID会被重新分配&lt;/li&gt;
      &lt;li&gt;ack=-1&lt;/li&gt;
      &lt;li&gt;Broker对&amp;lt;PID,Partition,SeqNumber&amp;gt;做缓存，过滤重复
***
        &lt;h3 id=&quot;消费策略&quot;&gt;消费策略&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;消息轮询 RoundRobin：按组划分&lt;/li&gt;
  &lt;li&gt;消息分段 Range：按主题划分&lt;/li&gt;
  &lt;li&gt;offset
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;group-id,topic,partition&amp;gt;确定一个offset&lt;/li&gt;
      &lt;li&gt;存储结构
        &lt;ul&gt;
          &lt;li&gt;zookeeper(0.9之前版本)
            &lt;ul&gt;
              &lt;li&gt;get /consumers/consumer-&lt;group-id&gt;/offsets/&lt;topics&gt;/&lt;partitions&gt;/&lt;offset&gt;&lt;/offset&gt;&lt;/partitions&gt;&lt;/topics&gt;&lt;/group-id&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;kafka(0.9版本开始)
            &lt;ul&gt;
              &lt;li&gt;
                &lt;__consumer_offsets&gt;
&lt;/__consumer_offsets&gt;
              &lt;/li&gt;
              &lt;li&gt;kafka-topics.sh –describe –topic __consumer_offsets –zookeeper zoo1:2181
***
                &lt;h3 id=&quot;高效读写&quot;&gt;高效读写&lt;/h3&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分区并发&lt;/li&gt;
  &lt;li&gt;顺序写磁盘&lt;/li&gt;
  &lt;li&gt;零拷贝
    &lt;ul&gt;
      &lt;li&gt;用户空间和内核空间的拷贝 =&amp;gt; transfer
***
        &lt;h3 id=&quot;broker主节点&quot;&gt;Broker主节点&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;zookeeper
    &lt;ul&gt;
      &lt;li&gt;get /controller
***
        &lt;h3 id=&quot;事务&quot;&gt;事务&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;0.11版本之后支持&lt;/li&gt;
  &lt;li&gt;Producer
    &lt;ul&gt;
      &lt;li&gt;Transaction Coordinator
        &lt;ul&gt;
          &lt;li&gt;TransactionID&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配合幂等性，ack=-1，事务可达到跨分区跨会话
***
    &lt;h3 id=&quot;发送消息流程&quot;&gt;发送消息流程&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Producer&lt;/li&gt;
  &lt;li&gt;Interceptors&lt;/li&gt;
  &lt;li&gt;Serializer&lt;/li&gt;
  &lt;li&gt;Partitioner&lt;/li&gt;
  &lt;li&gt;RecordAccumulator&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;topic&quot;&gt;topic&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;create topic
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kafka-topics.sh --create --zookeeper zoo1:2181 --replication-factor 1 --partitions 3 --topic book
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;list topic
```
kafka-topics.sh –zookeeper zoo1:2181 –list&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;describe&quot;&gt;describe&lt;/h1&gt;
&lt;p&gt;kafka-topics.sh –describe –topic book –zookeeper zoo1:2181&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- delete topic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;kafka-topics.sh –delete –zookeeper zoo1:2181 –topic book&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### producer
- console-producer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;kafka-console-producer.sh –broker-list localhost:9092 –topic book&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### consumer
- console-consumer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic book –from-beginning
kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic book –from-beginning –group test_group
```&lt;/p&gt;</content><author><name>Bob</name></author><summary type="html">Kafka</summary></entry><entry><title type="html">Spring中的设计模式</title><link href="/spring/2020/02/12/design-mode.html" rel="alternate" type="text/html" title="Spring中的设计模式" /><published>2020-02-12T13:57:36+08:00</published><updated>2020-02-12T13:57:36+08:00</updated><id>/spring/2020/02/12/design-mode</id><content type="html" xml:base="/spring/2020/02/12/design-mode.html"></content><author><name>Bob</name></author><summary type="html"></summary></entry><entry><title type="html">Kubernetes</title><link href="/docker/2020/02/12/kubernetes.html" rel="alternate" type="text/html" title="Kubernetes" /><published>2020-02-12T13:57:36+08:00</published><updated>2020-02-12T13:57:36+08:00</updated><id>/docker/2020/02/12/kubernetes</id><content type="html" xml:base="/docker/2020/02/12/kubernetes.html">&lt;h1 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h1&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;安裝部署&quot;&gt;安裝部署&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;kubeadm 环境准备
```shell
sysctemctl stop firewalld &amp;amp;&amp;amp; sysctemctl disable firewalld
yum install -y docker
systemctl enable docker &amp;amp;&amp;amp; systemctl start docker&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;重启后失效&quot;&gt;重启后失效&lt;/h1&gt;
&lt;p&gt;swapoff -a&lt;/p&gt;
&lt;h1 id=&quot;要永久禁掉swap分区打开如下文件注释掉swap那一行&quot;&gt;要永久禁掉swap分区，打开如下文件注释掉swap那一行&lt;/h1&gt;
&lt;p&gt;vim /etc/fstab&lt;/p&gt;

&lt;h1 id=&quot;rhel--centos-7上的一些用戶報告了由於iptables被繞過而導致流量路由不正確的問題您應該確保-netbridgebridge-nf-call-iptables在sysctl配置中設置為1&quot;&gt;RHEL / CentOS 7上的一些用戶報告了由於iptables被繞過而導致流量路由不正確的問題。您應該確保 net.bridge.bridge-nf-call-iptables在sysctl配置中設置為1&lt;/h1&gt;
&lt;p&gt;cat «EOF &amp;gt;  /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sysctl –system&lt;/p&gt;

&lt;h1 id=&quot;正式开始安装&quot;&gt;正式开始安装&lt;/h1&gt;
&lt;p&gt;cat «EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1&lt;/p&gt;
&lt;h1 id=&quot;切换阿里环境&quot;&gt;切换阿里环境&lt;/h1&gt;
&lt;h1 id=&quot;gpgkeyhttpsmirrorsaliyuncomkubernetesyumdocyum-keygpg&quot;&gt;gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg&lt;/h1&gt;
&lt;p&gt;gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF&lt;/p&gt;

&lt;h1 id=&quot;set-selinux-in-permissive-mode-effectively-disabling-it&quot;&gt;Set SELinux in permissive mode (effectively disabling it)&lt;/h1&gt;
&lt;h1 id=&quot;安全增强型-linuxsecurity-enhanced-linux简称-selinux-主要作用就是最大限度地减小系统中服务进程可访问的资源最小权限原则&quot;&gt;安全增强型 Linux(Security-Enhanced Linux)简称 SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源(最小权限原则)&lt;/h1&gt;
&lt;p&gt;/usr/sbin/sestatus -v # 查看SELinux状态&lt;/p&gt;
&lt;h1 id=&quot;关闭-selinux-权限限制&quot;&gt;关闭 SELinux 权限限制&lt;/h1&gt;
&lt;h1 id=&quot;第一种方式临时关闭不需要重启机器&quot;&gt;第一种方式临时关闭，不需要重启机器&lt;/h1&gt;
&lt;p&gt;setenforce 0&lt;/p&gt;
&lt;h1 id=&quot;第二种方式修改配置文件&quot;&gt;第二种方式修改配置文件&lt;/h1&gt;
&lt;p&gt;sed -i ‘s/^SELINUX=enforcing$/SELINUX=permissive/’ /etc/selinux/config&lt;/p&gt;

&lt;p&gt;yum install -y kubelet kubeadm kubectl –disableexcludes=kubernetes
systemctl enable –now kubelet&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  2. 配置ssh免密码访问
```shell
-- 修改hostname
hostnamectl --static set-hostname  kuber-master

ssh -o &quot;StrictHostKeyChecking no&quot; root@123456
ssh-keygen
ssh-copy-id -i ~/.ssh/id_rsa.pub root@kube1
ssh-copy-id -i ~/.ssh/id_rsa.pub root@kube2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;初始化master节点
```shell
    &lt;h1 id=&quot;下载镜像&quot;&gt;下载镜像&lt;/h1&gt;
    &lt;p&gt;kubeadm config images list
kubeadm config images pull&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;k8sgcriokube-apiserverv1153&quot;&gt;k8s.gcr.io/kube-apiserver:v1.15.3&lt;/h1&gt;
&lt;h1 id=&quot;k8sgcriokube-controller-managerv1153&quot;&gt;k8s.gcr.io/kube-controller-manager:v1.15.3&lt;/h1&gt;
&lt;h1 id=&quot;k8sgcriokube-schedulerv1153&quot;&gt;k8s.gcr.io/kube-scheduler:v1.15.3&lt;/h1&gt;
&lt;h1 id=&quot;k8sgcriokube-proxyv1153&quot;&gt;k8s.gcr.io/kube-proxy:v1.15.3&lt;/h1&gt;
&lt;h1 id=&quot;k8sgcriopause31&quot;&gt;k8s.gcr.io/pause:3.1&lt;/h1&gt;
&lt;h1 id=&quot;k8sgcrioetcd3310&quot;&gt;k8s.gcr.io/etcd:3.3.10&lt;/h1&gt;
&lt;h1 id=&quot;k8sgcriocoredns131&quot;&gt;k8s.gcr.io/coredns:1.3.1&lt;/h1&gt;

&lt;p&gt;kubeadm init –kubernetes-version=v1.15.3 –pod-network-cidr=10.244.0.0/16&lt;/p&gt;

&lt;p&gt;kubeadm join 192.168.127.70:6443 –token t0xrfm.n1cpx8k1g84e7u8u &lt;br /&gt;
    –discovery-token-ca-cert-hash sha256:49772aa397f90e5d06d0c02e080156cdd740930d0fa3f371f2dcd87790dce568&lt;/p&gt;

&lt;h1 id=&quot;配置普通用户可以运行-kubectl-命令&quot;&gt;配置普通用户可以运行 kubectl 命令&lt;/h1&gt;
&lt;h1 id=&quot;root-账号执行&quot;&gt;root 账号执行&lt;/h1&gt;
&lt;p&gt;export KUBECONFIG=/etc/kubernetes/admin.conf&lt;/p&gt;
&lt;h1 id=&quot;普通账号执行&quot;&gt;普通账号执行&lt;/h1&gt;
&lt;p&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  4. 安装pod網絡加載項
```shell
# For flannel to work correctly, you must pass --pod-network-cidr=10.244.0.0/16 to kubeadm init
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/62e44c867a2846fefb68bd5f178daf4da3095ccb/Documentation/kube-flannel.yml

# For Calico to work correctly, you need to pass --pod-network-cidr=192.168.0.0/16 to kubeadm init
kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;安装dashboard
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta3/aio/deploy/recommended.yaml
kubectl proxy &lt;span class=&quot;nt&quot;&gt;--address&lt;/span&gt; 0.0.0.0 &lt;span class=&quot;nt&quot;&gt;--accept-hosts&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'.*'&lt;/span&gt;
kubectl proxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;常用命令&quot;&gt;常用命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;kubeadm
    &lt;ol&gt;
      &lt;li&gt;kubeadm token create # 令牌在24小時後過期,&lt;/li&gt;
      &lt;li&gt;kubeadm token list&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;kubectl
    &lt;ol&gt;
      &lt;li&gt;kubectl version # 查看Kubernetes集群和客户端版本&lt;/li&gt;
      &lt;li&gt;kubectl api-versions # 查看api版本 group/version&lt;/li&gt;
      &lt;li&gt;kubectl get pods –all-namespaces # 获取所有 pod&lt;/li&gt;
      &lt;li&gt;kubectl get nodes # 获取所有集群节点&lt;/li&gt;
      &lt;li&gt;kubectl cluster-info # 获取集群信息&lt;/li&gt;
      &lt;li&gt;从集群中移除节点
        &lt;ol&gt;
          &lt;li&gt;kubectl drain &lt;node name=&quot;&quot;&gt; --delete-local-data --force --ignore-daemonsets # 主节点上运行&lt;/node&gt;&lt;/li&gt;
          &lt;li&gt;kubectl delete node &lt;node name=&quot;&quot;&gt; # 主节点上运行&lt;/node&gt;&lt;/li&gt;
          &lt;li&gt;kubeadm reset # 在要刪除的節點上，重置所有kubeadm安裝狀態&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;kubectl describe nodes kube0 # 获取单个节点描述&lt;/li&gt;
      &lt;li&gt;kubectl describe pods etcd-kube0 -n kube-system # 获取单个pod描述&lt;/li&gt;
      &lt;li&gt;kubectl get deployment coredns -n kube-system # 查看部署的pod集群状态&lt;/li&gt;
      &lt;li&gt;kubectl get deployment coredns -n kube-system -o yaml # 查看部署时的yaml描述&lt;/li&gt;
      &lt;li&gt;kubectl edit service kubernetes-dashboard -n kubernetes-dashboard # 编辑部署时的yaml描述&lt;/li&gt;
      &lt;li&gt;kubectl get service kubernetes-dashboard -n kubernetes-dashboard&lt;/li&gt;
      &lt;li&gt;kubectl get pod kubernetes-dashboard-7d8b9cc8d-fz5qz -n kubernetes-dashboard -o wide&lt;/li&gt;
      &lt;li&gt;kubectl get pod kubernetes-dashboard-7d8b9cc8d-fz5qz -n kubernetes-dashboard -o yaml&lt;/li&gt;
      &lt;li&gt;kubectl get svc –all-namespaces # service&lt;/li&gt;
      &lt;li&gt;kubectl get rc –all-namespaces # ReplicaController&lt;/li&gt;
      &lt;li&gt;kubectl get rs –all-namespaces # ReplicaSet&lt;/li&gt;
      &lt;li&gt;kubectl expose pods kubernetes-dashboard-7d8b9cc8d-fz5qz –type=NodePort -n kubernetes-dashboard # 暴露服务端口到外部&lt;/li&gt;
      &lt;li&gt;kubectl delete service kubernetes-dashboard-7d8b9cc8d-fz5qz -n kubernetes-dashboard # 删除创建的服务&lt;/li&gt;
      &lt;li&gt;kubectl get node –show-labels # 显示标签&lt;/li&gt;
      &lt;li&gt;kubectl label node kube1 label:value # 设置标签&lt;/li&gt;
      &lt;li&gt;kubectl get namespaces&lt;/li&gt;
      &lt;li&gt;kubectl logs dashboard-metrics-scraper-fb986f88d-2266s -n kubernetes-dashboard # 打印日志&lt;/li&gt;
      &lt;li&gt;kubectl exec&lt;/li&gt;
      &lt;li&gt;kubectl patch svc kubernetes-dashboard -p ‘{“spec”:{“type”:”NodePort”}}’ -n kubernetes-dashboard # 以打补丁方式修改dasboard的访问方式&lt;/li&gt;
      &lt;li&gt;kubectl get secret -n kubernetes-dashboard # 获取身份认证服务&lt;/li&gt;
      &lt;li&gt;kubectl describe secret kubernetes-dashboard-token-wl8wl -n kubernetes-dashboard # 获取登录token&lt;/li&gt;
      &lt;li&gt;kubectl get sa –all-namespaces # 获取serviceAccount&lt;/li&gt;
      &lt;li&gt;kubectl get role –all-namespaces # 获取集群角色&lt;/li&gt;
      &lt;li&gt;kubectl get clusterrolebinding # 获取集群角色绑定&lt;/li&gt;
      &lt;li&gt;kubectl describe clusterrolebinding cluster-admin # 角色绑定详情描述&lt;/li&gt;
      &lt;li&gt;kubectl describe role kubernetes-dashboard -n kubernetes-dashboard # 获取角色详情&lt;/li&gt;
      &lt;li&gt;kubectl describe clusterrole cluster-admin -n kube-system # 获取集群角色详情&lt;/li&gt;
      &lt;li&gt;kubectl create clusterrolebinding kubernetes-dashboard-admin –clusterrole=cluster-admin –serviceaccount=kubernetes-dashboard:kubernetes-dashboard # 绑定serviceaccount和clusterrole, namespace:name&lt;/li&gt;
      &lt;li&gt;kubectl describe secret kubernetes-dashboard-token-wl8wl -n kubernetes-dashboard # 获取集群权限token&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;問題解決&quot;&gt;問題解決&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;coredns 启动失败
```shell
kubectl get deployment coredns -n kube-system -o yaml | &lt;br /&gt;
  sed ‘s/allowPrivilegeEscalation: false/allowPrivilegeEscalation: true/g’ | &lt;br /&gt;
  kubectl apply -f -&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;似乎有3種不同的解決方法：&lt;/p&gt;

&lt;p&gt;升級到更新版本的docker，例如17.03，k8s目前推薦的版本
或者從部署的pod規範中刪除allowPrivilegeEscalation = false
或者禁用SELinux&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
# 其它资料
[Kubernetes部署](https://yq.aliyun.com/articles/682810 &quot;利用 Kubeadm部署 Kubernetes 1.13.1 集群实践录&quot;)  
[Dashboard安装](https://andrewpqc.github.io/2018/04/24/setup-k8s-dashboard-on-cluster &quot;Dashboard生成SSL安全证书&quot;)

1. VMware安装一台centos7，并安装docker  
2. 拷贝多份虚拟机，并为每一台修改 host  
```shell
hostnamectl --static set-hostname  kuber-master  
hostnamectl --static set-hostname  kuber-slave1  
hostnamectl --static set-hostname  kuber-slave2  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;修改ifcfg-env hosts 文件，并重启网络 service restart network&lt;/li&gt;
  &lt;li&gt;硬件限制&lt;br /&gt;
每台机器2 GB或更多的RAM（任何更少的内存将为您的应用留下很小的空间）
2个CPU或更多&lt;br /&gt;
[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2&lt;br /&gt;
kubeadm init –kubernetes-version=v1.13.1 –pod-network-cidr=10.244.0.0/16 –ignore-preflight-errors=NumCPU&lt;br /&gt;
error execution phase wait-control-plane: couldn’t initialize a Kubernetes cluster&lt;/li&gt;
  &lt;li&gt;no set 1 error&lt;br /&gt;
将命令echo “1” &amp;gt; /proc/sys/net/ipv4/ip_forward 写入脚本/etc/rc.d/rc.local
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/net/ipv4/ip_forward  
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /proc/sys/net/bridge/bridge-nf-call-iptables
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;查看占用端口进程
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;net-tools  
netstat &lt;span class=&quot;nt&quot;&gt;-tunlp&lt;/span&gt;|grep port  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;安装
```
curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;chmod +x ./kubectl&lt;/p&gt;

&lt;p&gt;sudo mv ./kubectl /usr/local/bin/kubectl&lt;/p&gt;

&lt;p&gt;kubectl version&lt;/p&gt;

&lt;p&gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;8. 查看状态(STATUS:ContainerCreating)  
```shell
kubectl get pods --all-namespaces -o wide  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;容器详细描述
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl describe node server0  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;对于swap的限制
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 重启后失效&lt;/span&gt;
swapoff &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;   
&lt;span class=&quot;c&quot;&gt;# 要永久禁掉swap分区，打开如下文件注释掉swap那一行 &lt;/span&gt;
vim /etc/fstab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;删除pod
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl delete pod NAME &lt;span class=&quot;nt&quot;&gt;--grace-period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Dashboard访问密钥
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create secret generic kubernetes-dashboard-certs &lt;span class=&quot;nt&quot;&gt;--from-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/share/certs &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; kube-system  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;生成token
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl describe secret/&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;kubectl get secret &lt;span class=&quot;nt&quot;&gt;-nkube-system&lt;/span&gt; |grep admin|awk &lt;span class=&quot;s1&quot;&gt;'{print $1}'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-nkube-system&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;kubectl命令自动补全
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; bash-completion
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /usr/share/bash-completion/bash_completion
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;kubectl completion bash&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;删除deployment
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get deployments  
kubectl delete deployments &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;NameOfDeployment]  
kubectl get rc
kubectl delete deployments &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;NameOfrc]  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;登录aliyun 镜像仓库
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker login registry.cn-shenzhen.aliyuncs.com/hizhangbo/test &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=[&lt;/span&gt;account &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;kompose安装
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Linux&lt;/span&gt;
curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://github.com/kubernetes/kompose/releases/download/v1.18.0/kompose-linux-amd64 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; kompose
&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x kompose
&lt;span class=&quot;nb&quot;&gt;sudo mv&lt;/span&gt; ./kompose /usr/local/bin/kompose
&lt;span class=&quot;c&quot;&gt;# autocomplete&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Bash (add to .bashrc for persistence)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;kompose completion bash&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;本地调试&lt;br /&gt;
&lt;em&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/&quot; title=&quot;kubernetes官网&quot;&gt;kubernetes官网&lt;/a&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;a href=&quot;https://www.telepresence.io/&quot; title=&quot;telepresence官网&quot;&gt;telepresence官网&lt;/a&gt;&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/&quot; title=&quot;kubeadm安装文档&quot;&gt;kubeadm安装文档&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Bob</name></author><summary type="html">Kubernetes</summary></entry><entry><title type="html">Zookeeper</title><link href="/2020/02/12/zookeeper.html" rel="alternate" type="text/html" title="Zookeeper" /><published>2020-02-12T13:57:36+08:00</published><updated>2020-02-12T13:57:36+08:00</updated><id>/2020/02/12/zookeeper</id><content type="html" xml:base="/2020/02/12/zookeeper.html">&lt;h1 id=&quot;zookeeper&quot;&gt;Zookeeper&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;docker-composeyml&quot;&gt;docker-compose.yml&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: '3.1'
services:
    zoo1:
        container_name: zookeeper1
        image: zookeeper:3.6.0
        hostname: zoo1
        ports:
            - 2181:2181
        environment:
            ZOO_MY_ID: 1
            ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181

    zoo2:
        container_name: zookeeper2
        image: zookeeper:3.6.0
        hostname: zoo2
        ports:
            - 2182:2181
        environment:
            ZOO_MY_ID: 2
            ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181

    zoo3:
        container_name: zookeeper3
        image: zookeeper:3.6.0
        hostname: zoo3
        ports:
            - 2183:2181
        environment:
            ZOO_MY_ID: 3
            ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;状态查看&quot;&gt;状态查看&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec zookeeper1 zkServer.sh status
docker exec zookeeper2 zkServer.sh status
docker exec zookeeper3 zkServer.sh status

# shell
#!/bin/bash

for i in $(seq 1 3)
do
  echo -e &quot;\033[32mZoo&quot;$i&quot; `docker exec zookeeper&quot;$i&quot; zkServer.sh status`\033[0m&quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;zkcli&quot;&gt;zkCli&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it --rm \
  --link zookeeper1:zk1 \
  --link zookeeper2:zk2 \
  --link zookeeper3:zk3 \
  --net zookeeper_default \
  zookeeper:3.6.0 zkCli.sh -server zk1:2181,zk2:2181,zk3:2181
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;常用命令&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 递归展示节点
ls -R /

# 创建节点
create /app1

# 实现一个分布式锁
# 1.创建一个临时节点
create -e /lock
# 2.监控锁的状态
stat -w /lock

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;version&quot;&gt;version&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;set -s -v 0 /node 1&lt;/li&gt;
  &lt;li&gt;无条件更新：-1&lt;/li&gt;
  &lt;li&gt;有条件更新：需要比较version，如果当前znode的version和修改的一样，才可更新
    &lt;h3 id=&quot;watch&quot;&gt;watch&lt;/h3&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;h3 id=&quot;存储架构&quot;&gt;存储架构&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;内存(memory)
    &lt;ul&gt;
      &lt;li&gt;data tree&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;硬盘(non-volatile storage)
    &lt;ul&gt;
      &lt;li&gt;事务日志
        &lt;ul&gt;
          &lt;li&gt;快照文件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Epoch
        &lt;ul&gt;
          &lt;li&gt;acceptedEpoch&lt;/li&gt;
          &lt;li&gt;currentEpoch
            &lt;h3 id=&quot;查看文件&quot;&gt;查看文件&lt;/h3&gt;
            &lt;p&gt;```&lt;/p&gt;
            &lt;h1 id=&quot;配置文件&quot;&gt;配置文件&lt;/h1&gt;
            &lt;p&gt;cat /conf/zoo.cfg&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;dataDir=/data
dataLogDir=/datalog&lt;/p&gt;

&lt;h1 id=&quot;查看日志文件&quot;&gt;查看日志文件&lt;/h1&gt;
&lt;p&gt;zkTxnLogToolkit.sh /datalog/version-2/log.100000001
```&lt;/p&gt;
&lt;h3 id=&quot;myid&quot;&gt;myid&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;server id
    &lt;h3 id=&quot;zxid&quot;&gt;zxid&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;每次对data tree的更新都会作为一个事务执行，并为每个事务编号zxid。&lt;/li&gt;
  &lt;li&gt;zxid是64位整数(long)，高4个字节保存epoch，低4个字节保存counter
    &lt;h3 id=&quot;epoch&quot;&gt;epoch&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;代表当前的Leader周期
    &lt;h3 id=&quot;finalizewait&quot;&gt;finalizeWait&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;QuorumPeer
    &lt;ul&gt;
      &lt;li&gt;startLeaderElection&lt;/li&gt;
      &lt;li&gt;createElectionAlgorithm
        &lt;ul&gt;
          &lt;li&gt;默认3：fastLeaderElection
            &lt;h3 id=&quot;分布式锁&quot;&gt;分布式锁&lt;/h3&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用临时节点
    &lt;ul&gt;
      &lt;li&gt;避免死锁&lt;/li&gt;
      &lt;li&gt;避免羊群效应&lt;/li&gt;
      &lt;li&gt;公平锁
        &lt;h3 id=&quot;zabzookeeper-atomic-broadcast协议&quot;&gt;ZAB(Zookeeper Atomic Broadcast)协议&lt;/h3&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1. Leader发送PROPOSAL给集群中的所有节点
    2. 节点收到PROPOSAL后，把PROPOSAL落盘，发送一个ACK给Leader
    3. Leader收到大多数节点的ACK之后，发送COMMIT给集群中所有的节点
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Bob</name></author><summary type="html">Zookeeper docker-compose.yml ``` version: ‘3.1’ services: zoo1: container_name: zookeeper1 image: zookeeper:3.6.0 hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181</summary></entry><entry><title type="html">MongoDB</title><link href="/2020/02/12/mongodb.html" rel="alternate" type="text/html" title="MongoDB" /><published>2020-02-12T13:57:36+08:00</published><updated>2020-02-12T13:57:36+08:00</updated><id>/2020/02/12/mongodb</id><content type="html" xml:base="/2020/02/12/mongodb.html">&lt;h1 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h1&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;創建用戶&quot;&gt;創建用戶&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 管理員
use admin
db.createUser(
  {
    user: &quot;admin&quot;,
    pwd: &quot;123456&quot;,
    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]
  }
)
db.auth('admin','123456')

# 普通用戶
use foo
db.createUser(
  {
    user: &quot;simpleUser&quot;,
    pwd: &quot;simplePass&quot;,
    roles: [ { role: &quot;readWrite&quot;, db: &quot;foo&quot; },
             { role: &quot;read&quot;, db: &quot;bar&quot; } ]
  }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;内置權限説明&quot;&gt;内置權限説明&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;read：允许用户读取指定数据库
readWrite：允许用户读写指定数据库
dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile
userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户
clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。
readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限
readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限
userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限
dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。
root：只在admin数据库中可用。超级账号，超级权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;可视化-mongodb-charts&quot;&gt;可视化 MongoDB Charts&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 镜像加速
docker pull quay.mirrors.ustc.edu.cn/mongodb/charts:19.12.1

# 启动 MongoDB Charts
docker run --rm quay.mirrors.ustc.edu.cn/mongodb/charts:19.12.1 charts-cli test-connection 'mongodb://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@host.docker.internal'

# 创建secret
echo &quot;mongodb://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@myhost.com/&quot; | docker secret create charts-mongodb-uri -

# 上面无法启动，需要使用swarm
docker stack deploy -c charts-docker-swarm-19.12.1.yml mongodb-charts

# 创建用户
docker exec -it \
  $(docker container ls --filter name=_charts -q) \
  charts-cli add-user --first-name &quot;bob&quot; --last-name &quot;zurk&quot; \
  --email &quot;zurkbob@gmail.com&quot; --password &quot;123456&quot; \
  --role &quot;UserAdmin&quot;

# 删除容器
docker stack rm mongodb-charts
docker volume rm mongodb-charts_keys
docker volume rm mongodb-charts_web-certs
docker volume rm mongodb-charts_db-certs
docker volume rm mongodb-charts_logs
docker secret rm charts-mongodb-uri
docker service ls

# 删除库
MongoDB Collections: metadata, app, auth, log, hosting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;windows-服务启动&quot;&gt;Windows 服务启动&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;D:\Program Files\MongoDB\Server\3.4\bin\mongod.exe&quot; --logpath &quot;D:\Program Files\MongoDB\data\log\mongodb.log&quot; --dbpath &quot;D:\Program Files\MongoDB\data\db&quot; --service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Bob</name></author><summary type="html">MongoDB</summary></entry><entry><title type="html">Spring</title><link href="/spring/2020/02/11/spring.html" rel="alternate" type="text/html" title="Spring" /><published>2020-02-11T13:57:36+08:00</published><updated>2020-02-11T13:57:36+08:00</updated><id>/spring/2020/02/11/spring</id><content type="html" xml:base="/spring/2020/02/11/spring.html">&lt;h1 id=&quot;spring&quot;&gt;Spring&lt;/h1&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;源碼編譯&quot;&gt;源碼編譯&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Within your locally cloned spring-framework working directory:
    &lt;ul&gt;
      &lt;li&gt;Precompile spring-oxm with ./gradlew :spring-oxm:compileTestJava&lt;/li&gt;
      &lt;li&gt;Import into IntelliJ (File -&amp;gt; New -&amp;gt; Project from Existing Sources -&amp;gt; Navigate to directory -&amp;gt; Select build.gradle)&lt;/li&gt;
      &lt;li&gt;When prompted exclude the spring-aspects module (or after the import via File-&amp;gt; Project Structure -&amp;gt; Modules)&lt;/li&gt;
      &lt;li&gt;Code away&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;gradle
    &lt;ul&gt;
      &lt;li&gt;修改構建文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;repositories {
       maven { url &quot;https://repo.spring.io/libs-release&quot; }
       maven{ url 'http://maven.aliyun.com/nexus/content/groups/public/'}
       google()
 } 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ioc容器&quot;&gt;IoC容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;定义
    &lt;ul&gt;
      &lt;li&gt;inversion of control (控制反转)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实现
    &lt;ul&gt;
      &lt;li&gt;service locator pattern 服务定位JNDI&lt;/li&gt;
      &lt;li&gt;template method design pattern 模板方法&lt;/li&gt;
      &lt;li&gt;strategy design pattern 策略模式&lt;/li&gt;
      &lt;li&gt;contextualized lookup 依赖查找&lt;/li&gt;
      &lt;li&gt;dependency injection 依赖注入&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;职责
    &lt;ul&gt;
      &lt;li&gt;依赖处理&lt;/li&gt;
      &lt;li&gt;生命周期管理
        &lt;ul&gt;
          &lt;li&gt;容器&lt;/li&gt;
          &lt;li&gt;托管资源&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;配置
        &lt;ul&gt;
          &lt;li&gt;容器&lt;/li&gt;
          &lt;li&gt;外部化配置&lt;/li&gt;
          &lt;li&gt;托管资源&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;依赖来源
    &lt;ul&gt;
      &lt;li&gt;自定义 Bean&lt;/li&gt;
      &lt;li&gt;容器内建Bean对象&lt;/li&gt;
      &lt;li&gt;容器内建依赖&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;配置元信息
    &lt;ul&gt;
      &lt;li&gt;Bean 定义配置
        &lt;ul&gt;
          &lt;li&gt;XML 文件&lt;/li&gt;
          &lt;li&gt;Properties 文件&lt;/li&gt;
          &lt;li&gt;Java 注解&lt;/li&gt;
          &lt;li&gt;Java API&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IoC 容器配置
        &lt;ul&gt;
          &lt;li&gt;XML&lt;/li&gt;
          &lt;li&gt;Java 注解&lt;/li&gt;
          &lt;li&gt;Java API&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;外部化属性配置
        &lt;ul&gt;
          &lt;li&gt;Java 注解&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对比&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;|类型|依赖处理|实现便利性|代码侵入性|API依赖性|可读性|
 |—|—|—|—|—|—|
 |依赖查找|主动获取|相对繁琐|侵入业务逻辑|依赖容器API|良好|
 |依赖注入|被动提供|相对便利|低侵入性|不依赖容器API|一般|&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;依赖查找
    &lt;ul&gt;
      &lt;li&gt;来源
        &lt;ul&gt;
          &lt;li&gt;BeanDefinition&lt;/li&gt;
          &lt;li&gt;SingletonObjects&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;方式
        &lt;ul&gt;
          &lt;li&gt;名称&lt;/li&gt;
          &lt;li&gt;类型&lt;/li&gt;
          &lt;li&gt;注解&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;依赖注入
    &lt;ul&gt;
      &lt;li&gt;来源
        &lt;ul&gt;
          &lt;li&gt;BeanDefinition&lt;/li&gt;
          &lt;li&gt;SingletonObjects&lt;/li&gt;
          &lt;li&gt;Dependency&lt;/li&gt;
          &lt;li&gt;@Value&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;方式
        &lt;ul&gt;
          &lt;li&gt;Setter&lt;/li&gt;
          &lt;li&gt;Constructor&lt;/li&gt;
          &lt;li&gt;Field&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;手动模式
        &lt;ul&gt;
          &lt;li&gt;XML&lt;/li&gt;
          &lt;li&gt;注解&lt;/li&gt;
          &lt;li&gt;API配置元信息&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;自动模式
        &lt;ul&gt;
          &lt;li&gt;Autowiring 自动绑定&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BeanFactory ApplicationContext
    &lt;ul&gt;
      &lt;li&gt;BeanFactory 是 Spring底层 Ioc容器&lt;/li&gt;
      &lt;li&gt;ApplicationContext 是具备应用特性的 BeanFactory 超集
        &lt;ul&gt;
          &lt;li&gt;AOP&lt;/li&gt;
          &lt;li&gt;Event publication&lt;/li&gt;
          &lt;li&gt;Message resource handling 国际化&lt;/li&gt;
          &lt;li&gt;WebApplicationContext&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bean&quot;&gt;Bean&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BeanDefinition
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;属性&lt;/th&gt;
              &lt;th&gt;说明&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;Class&lt;/td&gt;
              &lt;td&gt;全类名，必须是具体类，不能用抽象类或接口&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Name&lt;/td&gt;
              &lt;td&gt;名称或ID&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Scope&lt;/td&gt;
              &lt;td&gt;作用域&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Constructor arguments&lt;/td&gt;
              &lt;td&gt;构造器参数&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Properties&lt;/td&gt;
              &lt;td&gt;属性设置&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Autowiring mode&lt;/td&gt;
              &lt;td&gt;自动绑定&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Lazy initialization mode&lt;/td&gt;
              &lt;td&gt;延迟初始化模式&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Initialization method&lt;/td&gt;
              &lt;td&gt;初始化回调方法名称&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;Destruction method&lt;/td&gt;
              &lt;td&gt;销毁回调方法名称&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓存
    &lt;ul&gt;
      &lt;li&gt;singletonObjects 单例缓存池&lt;/li&gt;
      &lt;li&gt;singletonFactories 工厂-对象增强 AOP实现&lt;/li&gt;
      &lt;li&gt;earlySingletonObjects 三级缓存-防止重复创建&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;生命周期（单例）
    &lt;ul&gt;
      &lt;li&gt;xml/annotation 解析成 BeanDefinition&lt;/li&gt;
      &lt;li&gt;如果存在循环依赖 提前将对象暴露 addSingletonFactory&lt;/li&gt;
      &lt;li&gt;执行后置处理器(Aware接口/注解等) applyBeanPostProcessorsBeforeInitialization
        &lt;ul&gt;
          &lt;li&gt;策略模式 调用BeanPostProcessor的postProcessBeforeInitialization&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;反射创建对象&lt;/li&gt;
      &lt;li&gt;初始化对象
        &lt;ul&gt;
          &lt;li&gt;存在循环依赖 为循环依赖提供代理对象 getSingletonFactory&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;添加到单例对象缓存池 addSingletonObjects&lt;/li&gt;
      &lt;li&gt;关闭ApplicationContext destroyBeans&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注解&quot;&gt;注解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;注册组件
    &lt;ul&gt;
      &lt;li&gt;包扫描
        &lt;ul&gt;
          &lt;li&gt;@ComponentScan&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;组件注解
        &lt;ul&gt;
          &lt;li&gt;@Controller/@Service/@Repository/@Component&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;导入方式
        &lt;ul&gt;
          &lt;li&gt;@Bean&lt;/li&gt;
          &lt;li&gt;@Import
            &lt;ul&gt;
              &lt;li&gt;ImportSelector&lt;/li&gt;
              &lt;li&gt;ImportBeanDefinitionRegistrar&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;@Primary&lt;/li&gt;
          &lt;li&gt;@Conditional&lt;/li&gt;
          &lt;li&gt;@Lazy&lt;/li&gt;
          &lt;li&gt;@Scope&lt;/li&gt;
          &lt;li&gt;FactoryBean
            &lt;ul&gt;
              &lt;li&gt;默认取得方法getObject创建的目标对象&lt;/li&gt;
              &lt;li&gt;&amp;amp;beanName取得FactoryBean本身&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;组件赋值
        &lt;ul&gt;
          &lt;li&gt;@Value&lt;/li&gt;
          &lt;li&gt;@Autowired
            &lt;ul&gt;
              &lt;li&gt;@Qualifier&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;@Resources (JSR250)&lt;/li&gt;
          &lt;li&gt;@Inject(JSR330,导入包javax.inject)&lt;/li&gt;
          &lt;li&gt;@PropertySource&lt;/li&gt;
          &lt;li&gt;@PropertySources&lt;/li&gt;
          &lt;li&gt;@Profile&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;事件监听
        &lt;ul&gt;
          &lt;li&gt;@EventListener&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Aop
        &lt;ul&gt;
          &lt;li&gt;@EnableAspectJAutoProxy&lt;/li&gt;
          &lt;li&gt;@Aspect&lt;/li&gt;
          &lt;li&gt;@Pointcut&lt;/li&gt;
          &lt;li&gt;@Before/@After/@AfterReturning/@AfterThrowing/@Around&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Transaction
        &lt;ul&gt;
          &lt;li&gt;@EnableTransactionManagement&lt;/li&gt;
          &lt;li&gt;@Transactional&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;webflux&quot;&gt;WebFlux&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;相关前提
    &lt;ul&gt;
      &lt;li&gt;Reactor 同步非阻塞模式&lt;/li&gt;
      &lt;li&gt;Proactor 异步非阻塞模式&lt;/li&gt;
      &lt;li&gt;Observer 观察者模式&lt;/li&gt;
      &lt;li&gt;Iterator 迭代器模式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reactive
    &lt;ul&gt;
      &lt;li&gt;定义
        &lt;ul&gt;
          &lt;li&gt;声明式的编程范式，关注于数据流（data streams）和传播变化（propagation of change）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;实现
        &lt;ul&gt;
          &lt;li&gt;RxJava: Reactive Extensions&lt;/li&gt;
          &lt;li&gt;Reactor: Spring WebFlux Reactive&lt;/li&gt;
          &lt;li&gt;Flow API: JAVA 9 Flow API&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;特点
        &lt;ul&gt;
          &lt;li&gt;响应式（Responsive）&lt;/li&gt;
          &lt;li&gt;适应性强（Resilient）&lt;/li&gt;
          &lt;li&gt;弹性可伸缩（Elastic）&lt;/li&gt;
          &lt;li&gt;消息驱动（Message Driven）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;涉及技术
        &lt;ul&gt;
          &lt;li&gt;数据流：Java 8 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;传播变化： Java &lt;code class=&quot;highlighter-rouge&quot;&gt;Observable/Observer&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;事件： Java &lt;code class=&quot;highlighter-rouge&quot;&gt;EventObject/EventListener&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数据结构
        &lt;ul&gt;
          &lt;li&gt;流式 &lt;code class=&quot;highlighter-rouge&quot;&gt;stream&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;序列 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequences&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;Events&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;设计模式
        &lt;ul&gt;
          &lt;li&gt;扩展模式：观察者 &lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt; -&amp;gt; 推模式：被动获取事件&lt;/li&gt;
          &lt;li&gt;对立模式：迭代器 &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt; -&amp;gt; 拉模式：主动获取事件&lt;/li&gt;
          &lt;li&gt;混合模式：反应堆 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reactor&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;Proactor&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Bob</name></author><summary type="html">Spring</summary></entry><entry><title type="html">Netty</title><link href="/netty/2020/02/11/netty.html" rel="alternate" type="text/html" title="Netty" /><published>2020-02-11T13:57:36+08:00</published><updated>2020-02-11T13:57:36+08:00</updated><id>/netty/2020/02/11/netty</id><content type="html" xml:base="/netty/2020/02/11/netty.html">&lt;h1 id=&quot;netty&quot;&gt;Netty&lt;/h1&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;三种I/O模型
    &lt;ul&gt;
      &lt;li&gt;BIO（阻塞同步）
        &lt;ul&gt;
          &lt;li&gt;连接数少，并发度低，所以Netty已不再支持&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NIO（非阻塞同步）
        &lt;ul&gt;
          &lt;li&gt;不同平台不同实现&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;AIO（非阻塞异步）
        &lt;ul&gt;
          &lt;li&gt;Linux中相比NIO性能没有明显提升，所以Netty已不再支持&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reactor模式
    &lt;ul&gt;
      &lt;li&gt;核心思想
        &lt;ul&gt;
          &lt;li&gt;事件注册&lt;/li&gt;
          &lt;li&gt;事件监听&lt;/li&gt;
          &lt;li&gt;事件处理&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;三种Reactor模式（NioEventLoopGroup）
        &lt;ul&gt;
          &lt;li&gt;单线程模式
            &lt;ul&gt;
              &lt;li&gt;由一个线程负责处理所有事件&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;多线程模式
            &lt;ul&gt;
              &lt;li&gt;由一个线程池来处理decode/compute/encode三种操作&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;主从多线程模式
            &lt;ul&gt;
              &lt;li&gt;将acceptor连接事件注册到单独的reactor中，其他事件注册到另外的reactor中&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对TCP粘包和半包的支持
    &lt;ul&gt;
      &lt;li&gt;根本原因
        &lt;ul&gt;
          &lt;li&gt;TCP是流式协议，消息无边界&lt;/li&gt;
          &lt;li&gt;提醒：UDP消息有边界，无半包粘包问题&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;解决方式
        &lt;ul&gt;
          &lt;li&gt;TCP连接改为短连接：按请求次数划分消息边界&lt;/li&gt;
          &lt;li&gt;封装成帧（Framing）
            &lt;ul&gt;
              &lt;li&gt;固定长度：空间浪费&lt;/li&gt;
              &lt;li&gt;分隔符：需要转义&lt;/li&gt;
              &lt;li&gt;固定长度标记消息长度：需要提前预知最大长度&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;netty中对Framing操作的支持
        &lt;ul&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th&gt;方式&lt;/th&gt;
                  &lt;th&gt;解码&lt;/th&gt;
                  &lt;th&gt;编码&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;固定长度&lt;/td&gt;
                  &lt;td&gt;FixedLengthFrameDecoder&lt;/td&gt;
                  &lt;td&gt; &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td&gt;分隔符&lt;/td&gt;
                  &lt;td&gt;DelimiterBasedFrameDecoder&lt;/td&gt;
                  &lt;td&gt; &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td&gt;固定长度标记消息长度&lt;/td&gt;
                  &lt;td&gt;LengthFieldBasedFrameDecoder&lt;/td&gt;
                  &lt;td&gt;LengthFieldPrepender&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常用元素
    &lt;ul&gt;
      &lt;li&gt;EventLoopGroup # 事件循环组
        &lt;ul&gt;
          &lt;li&gt;TerminationListener&lt;/li&gt;
          &lt;li&gt;EventExecutor
            &lt;ul&gt;
              &lt;li&gt;EventExecutorChooser # Channel选择绑定EventLoop的方式
                &lt;ul&gt;
                  &lt;li&gt;PowerOfTwoEventExecutorChooser # 如果executors的个数为2的幂次方则使用，效率更高&lt;/li&gt;
                  &lt;li&gt;GenericEventExecutorChooser # 如果不是2的幂次方，则使用求余取绝对值的普通方式&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;EventLoop
                &lt;ul&gt;
                  &lt;li&gt;SingleThreadEventLoop
                    &lt;ul&gt;
                      &lt;li&gt;NioEventLoop
                        &lt;ul&gt;
                          &lt;li&gt;select&lt;/li&gt;
                          &lt;li&gt;processSelectedKeys&lt;/li&gt;
                          &lt;li&gt;runAllTasks&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;ThreadPerTaskExecutor&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ServerBootstrap # 服务器引导启动与初始化
        &lt;ul&gt;
          &lt;li&gt;ChannelFactory
            &lt;ul&gt;
              &lt;li&gt;NioServerSocketChannel&lt;/li&gt;
              &lt;li&gt;SocketChannel&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ChannelPipeline
        &lt;ul&gt;
          &lt;li&gt;ChannelHandler
            &lt;ul&gt;
              &lt;li&gt;ChannelInboundHandlerAdapter&lt;/li&gt;
              &lt;li&gt;ChannelOutboundHandlerAdapter&lt;/li&gt;
              &lt;li&gt;HeadContext
                &lt;ul&gt;
                  &lt;li&gt;实现ChannelOutboundHandler, ChannelInboundHandler&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;TailContext
                &lt;ul&gt;
                  &lt;li&gt;实现ChannelInboundHandler&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;编码
        &lt;ul&gt;
          &lt;li&gt;Protobuf
            &lt;ul&gt;
              &lt;li&gt;优势
                &lt;ul&gt;
                  &lt;li&gt;比序列化方式效率高&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;内存泄漏检测
        &lt;ul&gt;
          &lt;li&gt;ResourceLeakDetector.level # 检测等级&lt;/li&gt;
          &lt;li&gt;-Dio.netty.leakDetection.level=PARANOID&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;线程模型优化
        &lt;ul&gt;
          &lt;li&gt;UnorderedThreadPoolEventExecutor # 使业务线程独立
            &lt;ul&gt;
              &lt;li&gt;NioEventExecutorGroup 会判断是否绑定同一个channel，如果是则只利用一个线程工作，所以这里使用UnorderedThreadPoolEventExecutor&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;吞吐量优化
        &lt;ul&gt;
          &lt;li&gt;FlushConsolidationHandler # 延迟批量发送
            &lt;ul&gt;
              &lt;li&gt;pipeline.addLast(“flushEnhance”, new FlushConsolidationHandler(5, true));&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;流量整型
        &lt;ul&gt;
          &lt;li&gt;ChannelTrafficShapingHandler&lt;/li&gt;
          &lt;li&gt;GlobalTrafficShapingHandler: share&lt;/li&gt;
          &lt;li&gt;GlobalChannelTrafficShapingHandler: share&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Bob</name></author><summary type="html">Netty</summary></entry></feed>